<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue组件间通信]]></title>
    <url>%2Fvue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[简单说一下vue组件间的通信 1.父组件向子组件传递数据通过 Prop 向子组件传递数据 1.在父组件中注册子组件2.在子组件中声名props,接收从父组件传过来的值3.在子组件的标签中使用props创建的属性4.在父组件中，把要传给子组件的值赋值给props创建的属性 示例： 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;child :message="message"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; // 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data:&#123; message:'Hello' &#125;&#125;)&lt;/script&gt; 2.子组件向父组件传递数据子组件通过事件向父组件发送消息 1.在子组件中以某种方式，触发一个自定义事件2.利用$emit,将需要传的值作为第二个参数传过去，或者只是触发父组件中相对应的事件3.父组件在使用子组件的地方直接用 v-on 来监听子组件触发的事件，通过 $event 访问到子组件传过来的值，或者这个事件处理函数是一个方法。 示例： 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="app"&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; // 'v-on' 可用 '@' 代替，'v-bind' 可用 ':'代替 // 用 v-on 来监听子组件触发的事件 &lt;button-counter @increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter @increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 子组件Vue.component('button-counter', &#123; template: '&lt;button @click="incrementHandler"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter += 1 // 触发一个自定义事件 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 有时我们也会同时用到这两种通信方式 示例： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;我是子组件传递给父组件的数据:&lt;/p&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter @increment="incrementTotal" :message='message'&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; Vue.component('button-counter', &#123; template: '&lt;div&gt;&lt;p&gt;我是父组件传给子组件的信息:&lt;/p&gt;&lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;button @click="incrementHandler"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&lt;/div&gt;', props: ['message'], data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter += 1; this.$emit('increment', this.counter); &#125; &#125;, &#125;) new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0, message: '请点击按钮' &#125;, methods: &#123; incrementTotal: function (counter) &#123; this.total = counter; &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>组件间通信</tag>
        <tag>prop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件keep-alive]]></title>
    <url>%2Fvue%E7%BB%84%E4%BB%B6keep-alive%2F</url>
    <content type="text"><![CDATA[vue组件 keep-alive使用简介 keep-alive适用于动态组件中，当在组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。 keep-alive让组件实例能够被在它们第一次被创建的时候缓存下来。 注意这个 &lt;keep-alive&gt; 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。 Props：include - 字符串或正则表达式。只有名称匹配的组件会被缓存。exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。max - 数字。最多可以缓存多少组件实例。 用法：&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。&lt;keep-alive&gt;是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 示例：主要用于保留组件状态或避免重新渲染。 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt; &lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; include and exclude include 和 exclude属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： 1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include="a,b"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include="['a', 'b']"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 具体示例： 一个简单的tab切换,可以尝试把&lt;keep-alive&gt;去掉之后,对比一下,然后就会发现它的好处。 test.vue12345678910111213141516&lt;template&gt; &lt;div class="test"&gt; &lt;div class="testNav"&gt; &lt;div :class="&#123;'selected':tab === 1,'testTitle':true&#125;" @click="toTab(1)"&gt;标题一&lt;/div&gt; &lt;div :class="&#123;'selected':tab === 2,'testTitle':true&#125;" @click="toTab(2)"&gt;标题二&lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;keep-alive&gt; &lt;Test1 v-if="tab === 1"&gt; &lt;/Test1&gt; &lt;Test2 v-else&gt; &lt;/Test2&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; import Test1 from './test1.vue'; import Test2 from './test2.vue'; export default &#123; data() &#123; return &#123; tab: 1, &#125;; &#125;, components: &#123; Test1, Test2, &#125;, methods: &#123; toTab(index) &#123; this.tab = index; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123; width: 100%; .testNav &#123; height: 60px; line-height: 60px; display: flex; border-bottom: 1px solid #e5e5e5; .testTitle &#123; flex: 1; text-align: center; &#125; .selected &#123; color: red; &#125; &#125;&#125;&lt;/style&gt; test1.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class="test1"&gt; test1 &#123;&#123;testInfo1&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo1: '', &#125;; &#125;, activated() &#123; console.log('测试1被激活'); &#125;, deactivated() &#123; console.log('测试1被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo1 = '这是测试一的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; test2.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; test2 &#123;&#123;testInfo2&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo2: '', &#125; &#125;, activated() &#123; console.log('测试2被激活'); &#125;, deactivated() &#123; console.log('测试2被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo2 = '这是测试二的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; 运行代码，打开控制台，你会更直观的看到keep-alive的作用，以及activated和deactivated这两个函数被触发的时间 用setTimeout模拟请求后端接口 1.刚打开页面： 2.点击标题二 3.再次点击标题一，你会发现信息会快速显示出来： 上述示例代码原引用作者 funnycoderstar，链接https://juejin.im/post/5ad56d86518825556534ff4b 以上是添加了keep-alive的情况下，如果去掉keep-alive，每次切换tab你会发现都会重新请求一次数据，感兴趣的可以尝试一下。 注：匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。 max 最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。 123&lt;keep-alive :max="10"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的网页设计错误（下）]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为翻译的原文 原文地址http://blog-en.tilda.cc/articles-website-design-mistakes 文章设计中的错误1.长而坚固的副本文本墙使阅读难以理解。为了便于导航，将其拆分为段落或引入诸如关键短语或图像之类的中断。图1-1，文字墙很难看。图1-2，拉引号或图像等元素使阅读文本更容易。 2.标题位于前一段和下一段之间相同的距离标题不应该在类似距离的章节之间“挂起”，因为它属于下面的段落。标题上方的距离应比其下方的空间大2-3倍。同时，标题下的距离应与段落之间的距离大致相同，或稍大一些。这样，标题将在视觉上引用后续文本。图2-1，标题位于其上方和下方的段落之间的相等距离​​处，并且不清楚它属于哪个段落。图2-2，由于在标题下使用了填充，很明显标题属于下面的文本。 3.没有逻辑顺序在排版中，对比用于在视觉上划分不同级别的文本并建立严格的层次结构。主标题应该是页面上最突出的，副标题应该相当小但仍然清晰可见。图3-1，标题和子标题大小大致相同，它们之间没有明确的层次结构。图3-2，从逻辑上讲，标题比子标题更重要。 4.块上方和下方的填充不同如果块具有相同的重量，则它们应具有相同的外观和感觉并且彼此之间的距离相等。图4-1，如果标题和作者图像之间的空间太窄，看起来好像作者更多地关注标题而不是后面的文本。图4-2，由于图像上方和下方的相同尺寸填充，块看起来相同。 5.标题位置太靠近图像一方面，插图及其标题形成一个整体，但这些是两个独立的元素，并且标题不应干扰图像。图5-1，标题贴在图像上，我们无法正确地与其中任何一个进行交互。图5-2，图像与其标题之间有很多空白区域，但很明显标题与图像一致。 6.副标题和文本副本之间的空间太小后面的小标题和文本副本属于一起，但如果文章中段落之间的空格大于子标题和下一段之间的空格，则该文章看起来脱节。图6-1，标题和段落之间的空间小于段落之间的空间。图6-2，标题后的空格略大于段落之间的空格。 7.突出元素放置得太靠近正文用作重点表达的元素（如关键短语或引号）是独立的对象。要让它们真正脱颖而出，请将它们设置为75-120像素的主体副本。图7-1，主要文本和突出元素之间的空间太小。图7-2，由于大填充，拉引号真正脱颖而出。 8.低对比度元素如果您想强调某个短语，请加粗，使一个关键短语大于主文本10-15 px。让关键短语从文本的其余部分中脱颖而出。图8-1，关键短语与副本的其余部分混合在一起。它看起来很乱，所以尽量避免这种情况。图8-2，现在每个人都可以看到它，这要归功于大字体和文本周围足够的填充。 9.窄文本块的彩色背景如果您想突出显示页面的一小部分（例如作者信息），则足以在此周围设置足够的填充，这将产生空间印象。不要将此部分放在彩色背景上; 这看起来不合适。 不要使用颜色作为子标题。使用更大的字体和填充应足以使其在页面上弹出 10.两个全屏图像之间有一个空白区域在序列中使用多个全屏图像时，请避免在它们之间留出空格。边框仍然可见，并且无需添加其他元素。它只是没有添加任何东西。图10-1，全屏图像之间的空白空间毫无意义，看起来不太好。图10-2，在这个例子中，图像之间存在和谐的流动。 11.使用了太多的设计口音设计重音（例如这里的粗体）很少有效。放入太多，这将妨碍阅读页面。许多单词以粗体标记，因此文本副本显示为已损坏一些标记的词语引起了对自己的注意，并且不会干扰文本的其余部分 12.排版样式太多设计不应干扰可读性。排版样式越少，重要的元素就越明显。它足以强调标题和小标题，并使用对比关键短语。图12-1，这个文本有太多的排版设备。他们分散了读者的注意力。图12-2，很少排版样式，重点很明确，并且观察文本层次。 13.在长篇文章中集中文本中心通常应用于标题和块引号，以区别于文本的其余部分。中心长文本难以阅读。图13-1，中心文本看起来很乱，而且很难阅读。图13-2，左侧对齐的文字很容易在眼睛上。 14.标题看起来太靠近图像了标题是个人设计元素。它不应该太靠近随后的图像。对于获胜组合，设置不小于60像素的填充，并添加一个子标题 - 它将展开页面的内容并将正确的重点放在您需要的位置。图14-1，标题太靠近图像，此页面上没有喘息空间。图14-2，这里标题通过子标题与图像分开，并且它与整个部分有关，而不仅仅是图像。 15.在不需要时使用斜体斜体用于突出显示文本中的单词或短语。它不像粗体那样立即引人注目，但它确实可以让你在需要的地方强调它。 不要用斜体写出所有内容（正文，标题）。如果在文本副本中使用sans-serif字体，则完全避免使用斜体。由于字体大小和填充，这个短语已经突出，所以这里并不真正需要斜体。 斜体在正确的位置，增加了适当的重点。 16.块相对于页面中心和彼此显得不合适如果您在编辑页面后稍微休息一下（更改字体大小，对齐或缩进）并查看其中的内容，您可以轻松地自己发现此错误。图16-1，在此示例中，标题向左移动，文本复制到右侧。图16-2，所有文本元素都相互协调。]]></content>
      <categories>
        <category>网页设计</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器和CSS3属性]]></title>
    <url>%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8CCSS3%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文主要介绍CSS选择器和CSS3属性 1、CSS3的概念和优势A、CSS3的概念： CSS3并不是一门语言，我们知道css是层叠样式表，是一种样式语言，是用来告诉浏览器如何渲染页面的。css3是css规范的最新版本，在css2.1上增加了很多强大的新功能，用来帮助开发人员解决一些问题，并且不再需要非语义化标签，复杂的js脚本和图片，例如圆角、多背景、透明度、阴影等等。css2.1是单一的规范，而css3被划分成几个模块组，每个模块组都有自己的规范。这样的好处就是整个css3的规范发布不会因为部分而印象其他模块的推进。 B、css3的优势：1）让页面效果看起来非常炫酷，用户体验更高。2）有利于开发和维护，还能提高网站的性能，增加网站的可访问性，可用性。3）使网站能适配更多的设备，利于seo网站优化，提高网站的搜索排名。 C、CSS新特性：CSS3选择器、图片的视觉效果（圆角、阴影、渐变背景、图片边框等）、背景的应用（background-origin/background-clip/background-size）、盒模型的变化、阴影效果（文本阴影、盒子阴影）、多列布局和弹性盒布局、web文字和font图标、颜色和透明度、圆角和边框的新特效、2D和3D变形、CSS3过渡和动画效果、媒体查询和Responsive布局。 2、渐进增强和优雅降级的简介(扩展)渐进增强（progressive enhancement）：一开始只构建站点的最少特性，然后不断地对不同的浏览器追加不同的功能 优雅降级（graceful degradation）：一开始就构建站点的完整功能，然后针对浏览器进行测试和修复 `“优雅降级”和“渐进增强”都关注于同一网站在不同设备里不同浏览器下的表现程度。 关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。` “渐进增强”观点则认为应关注于内容本身。区别： 优雅降级即功能衰减是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强(pe)则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。功能衰减意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 3、CSS3 选择器——属性选择器CSS选择器的优势：可以帮助开发人员在开发中减少对html类名和id名的依赖，以及对html结构的依赖，使编写代码更加简单轻松。 1、E[attr]：只使用属性名，但没有确定任何属性值； 2、E[attr=”value”]：指定属性名，并指定了该属性的属性值； 3、E[attr~=”value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写 4、E[attr^=”value”]：指定了属性名，并且有属性值，属性值是以value开头的； 5、E[attr$=”value”]：指定了属性名，并且有属性值，而且属性值是以value结束的 6、E[attr*=”value”]：指定了属性名，并且有属性值，而且属值中包含了value； 7、E[attr|=”value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; 这些属性选择器除了IE6不支持。 4、CSS3 选择器——伪类选择器1）动态伪类动态伪类，因为这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来，动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如”:link”,”:visited”;另外一种被称作用户行为伪类最常见的锚点伪类：1234.demo a:link &#123;color:gray;&#125;/*链接没有被访问时*/.demo a:visited&#123;color:yellow;&#125;/*链接被访问过后*/.demo a:hover&#123;color:green;&#125;/*鼠标悬浮在链接上时*/.demo a:active&#123;color:blue;&#125;/*鼠标点中激活链接那一下*/ 对于这四个锚点伪类的设置，有一点需要特别注意，那就是他们的先后顺序，要让他们遵守一个爱恨原则LoVe/HAte,也就是Link–visited–hover–active。 2）UI元素状态伪类我们把&quot;:enabled&quot;,&quot;:disabled&quot;,&quot;:checked&quot;伪类称为UI元素状态伪类，这些主要是针对于HTML中的Form元素操作。IE6-8不支持&quot;:checked&quot;,&quot;:enabled&quot;,&quot;:disabled&quot;这三种选择器。 3）CSS3的:nth选择器这个是CSS3选择器最新部分，有人也称这种选择器为CSS3结构类，下面是他们的用法： ①:first-child选择某个元素的第一个子元素；IE6不支持:first-child选择器 ②:last-child选择某个元素的最后一个子元素； ③:nth-child()选择某个元素的一个或多个特定的子元素； A、:nth-child(length);/参数是具体数字/ B、:nth-child(n);/参数是n,n从0开始计算/请注意了，这里的“n”只能是”n”，不能使用其他字母代替，不然会没有任何效果的。 C、:nth-child(nlength)/n的倍数选择，n从0开始算*/ D、:nth-child(n+length);/选择大于length后面的元素/ E、:nth-child(-n+length)/选择小于length前面的元素/ F、:nth-child(nlength+1);/表示隔几选一*/这种方法是实现隔几选一的效果。 //上面length为整数,IE6-8和FF3-浏览器不支持”:nth-child”选择器。 ④:nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； ⑤:nth-of-type()选择指定的元素； nth-of-type类似于:nth-child，不同的是他只计算选择器中指定的那个元素，唯一不同的是这种指定了元素的类型而以。同样在IE6-8和FF3.0-浏览器不支持这种选择器 ⑥:nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； ⑦:first-of-type选择一个上级元素下的第一个同类子元素； ⑧:last-of-type选择一个上级元素的最后一个同类子元素； ⑨:only-child选择的元素是它的父元素的唯一一个了元素； ⑩:only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； ⑾:empty选择的元素里面没有任何内容。 4）否定选择器（:not）否定选择器 :not()，可以让你定位不匹配该选择器的元素。IE6-8浏览器不支持:not()选择器。 5）:root 选择文档的根元素:root{ background:green;}将样式绑定到页面的根元素中。所谓根元素，是指位于文档树中最顶层结构的元素，在HTML页面中就是值包含着整个页面的html部分 6）:target 选择器可用于选取当前活动的目标元素。使用该选择器来对页面中的某个target元素（该元素的id当做页面中的超链接来使用）指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用。 7）:lang 伪类:lang 伪类使你有能力为不同的语言定义特殊的规则。在下面的例子中，:lang 类为属性值为 no 的 q 元素定义引号的类型： 5、CSS3 选择器–伪元素1）伪元素CSS中的伪元素大家以前看过：:first-line,:first-letter,:before,:after;那么在CSS3中，他对伪元素进行了一定的调整，在以前的基础上增加了一个“：”也就是现在变成了“::first-letter,::first-line,::before,::after”另外他还增加了一个“::selection”,两个“：：”和一个“：”css3中主要用来区分伪类和伪元素，到目前来说，这两种方式都是被接受的，也就是说不管使用哪种写法所起的作用都是一样的，只是一个书写格式不同而以。 ::selection用来改变浏览网页选中文的默认效果。::selection在IE家族中，只有IE9+版本支持，在Firefox中需要加上其前缀“-moz” 6、CSS3 选择器——层次选择器1）后代选择器（Ｅ Ｆ）后代选择器也被称作包含选择器,所起作用就是可以选择某元素的后代元素，这里Ｆ不管是E元素的子元素或者是孙元素或者是更深层次的关系，都将被选中，换句话说，不论Ｆ在Ｅ中有多少层关系，都将被选中： 2）子元素选择器(E&gt;F)子元素选择器只能选择某元素的子元素，其中E为父元素，而F为子元素，其中E&gt;F所表示的是选择了Ｅ元素下的所有子元素Ｆ。 IE6不支持子元素选择器。 3）相邻兄弟元素选择器(E + F)相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素，换句话说，EF两元素具有一个相同的父元素，而且Ｆ元素在Ｅ元素后面，而且相邻，这样我们就可以使用相邻兄弟元素选择器来选择Ｆ元素。 IE6不支持这个选择器 4）通用兄弟选择器（Ｅ 〜 Ｆ）通用兄弟元素选择器是CSS3新增加一种选择器，这种选择器将选择某元素后面的所有兄弟元素，他们也和相邻兄弟元素类似，需要在同一个父元素之中，换句话说，E和F元素是属于同一父元素之内，并且F元素在Ｅ元素之后，那么E ~ F 选择器将选择中所有Ｅ元素后面的Ｆ元素。通用兄弟选择器和相邻兄弟选择器极其相似，只不过，相邻兄弟选择器仅选择是元素的仅与其相邻的后面元素（选中的仅一个元素）；而通用兄弟元素选择器，选中的是元素相邻的后面兄弟元素。IE6不支持这种选择器的用法。 7、CSS3私有属性什么是浏览器私有属性前缀？CSS3的浏览器私有属性前缀是一个浏览器生产商经常使用的一种方式。它暗示该CSS属性或规则尚未成为W3C标准的一部分。以下是几种常用前缀12-webkit- 谷歌 -moz- 火狐 -ms- IE浏览器 -o- 欧朋-khtml-（现在基本都没有用了，被-webkit-取代） 举例来说，一个CSS3圆角的代码是：1234567-webkit-border-radius: 50%;-o-border-radius: 50%;-moz-border-radius: 50%;-ms-border-radius: 50%; CSS3前缀+标准代码的顺序是什么？结论：是先写私有的CSS3属性，再写标准的CSS3属性。 123456789-webkit-transform:rotate(-3deg); /*为Chrome/Safari*/-moz-transform:rotate(-3deg); /*为Firefox*/-ms-transform:rotate(-3deg); /*为IE*/-o-transform:rotate(-3deg); /*为Opera*/transform:rotate(-3deg); /*为nothing*/ 什么时候我们可以去掉一个属性的CSS3前缀呢？ 答案是，当一个属性成为标准，并且被Firefox、Chrome等浏览器的最新版普遍兼容的时候。 8、CSS3新增属性1）text-shadow:5px 5px 5px #f66; 文字阴影语法： text-shadow: h-shadow v-shadow blur color; h-shadow 必需。水平阴影的位置。允许负值。为正值，阴影在对象的右边，反之阴影在对象的左边。 v-shadow 必需。垂直阴影的位置。允许负值。如果为正值，阴影在对象的底部，反之阴影在对象的顶部。 blur 可选。模糊的距离。 这个值只能是正值 color 可选。阴影的颜色。 注：Internet Explorer 9 以及更早版本的浏览器不支持 可是让我们头痛的是IE是不支持text-shadow效果，但为了在兼容这一问题，我们只好使用滤镜filter:shadow来处理（不提倡使用滤镜）。filter:shadow滤镜作用，也能使用对象产生阴影效果，不同的是shadow可产生渐近效果，使用阴影更平滑实现。 滤镜语法：E {filter:shadow(Color=颜色值,Direction=数值,Strength=数值)} 其中E是元素选择器，Color用于设定对象的阴影色；Direction用于设定投影的主向，取值为0即零度（表示向上方向），45为右上，90为右，135为右下，180为下方，225为左下方，270为左方，315为左上方；Strength就是强度，类似于text-shadow中的blur值。 2）box-shadow：让盒子在显示的时候产生阴影效果写法：box-shadow:length length length length color inset;1234567891011第一个参数表示阴影离开盒子的横向距离第二个参数表示阴影离开盒子的纵向距离第三个参数表示阴影的模糊半径第四个参数表示阴影的延伸半径 （可省略）第五个参数表示阴影的颜色第六个参数表示是否使用内阴影 （可省略，默认是外阴影） Box-shadow:inset 1px 1px 1px 1px #000, color inset的顺序可以改变 3）word-break:使用该属性自己决定自动换行的处理方法通过对其的指定，不仅仅可以让浏览器实现半角空格或连字符后面的换行，而且可以让浏览器实现任意位置的换行。 参数:normal/keep-all/break-all normal:使用浏览器默认换行规则，根据语言自己的规则确定换行方式，中文到边界上的汉字换行，英文从整个单词换行 keep-all:不允许字断开。在低版本的Chrome和Safari浏览器下不起任何效果 break-all:允许在单词内换行（对于标点符号来说，允许标点符号位于行首，不过在IE中是不可以的）可以强行截断英文单词，达到词内换行效果。 4）word-wrap: normal break-word;属性用来标明是否允许浏览器在单词内进行断句normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。将内容在边界内换行（不截断英文单词换行）。 5）服务器字体：123456789@font-face：字体语法 在网页上显示服务端字体font-family： 规定字体的名称。src:url 定义字体文件的 URL。font-stretch: 不常用，没有兼容 定义如何拉伸字体font-weight： 设置加粗 注：在IE中使用时，只能使用微软自带的Embedded OpenType字体文件，扩展名为.eot，同时不需要使用format属性值，用法如下 123@font-face&#123;font-family:BorderWeb;src:url(BORDERW0.eot);&#125; 在项目文件夹中的fonts文件内容分别包括粗体、斜体、粗斜体、小型大写字体 6）background-clip 指定背景的显示范围 border padding content概念：在HTML页面中，一个具有背景的元素通常由元素的内容，内部补白（padding），边框，外部补白（margin）构成 border-box 背景被裁剪到边框盒。 padding-box 背景被裁剪到内边距框。 content-box 背景被裁剪到内容框。 text 在Webkit内核下，background-clip还有一个text属性，配合Webkit内核的私有属性text-fill-color:transparent可以制作背景图片填充文本的效果 -webkit-background-clip: text; -webkit-text-fill-color: transparent;只有Webkit浏览器支持。 7）、background-origin 指定绘制背景图像时的起点规定 :background-position属性相对于什么位置来定位。 参数 padding-box背景图像相对于内边距框来定位。 border-box背景图像相对于边框盒来定位。 content-box背景图像相对于内容框来定位。 8）扩展知识点：background-clip与background-origin的用法区别？background-clip：border|padding|content background-origin属性是用来控制元素背景图片定位点（background-position）的起始位置。 background-clip属性是用来控制元素背景图片（background-image）的展示区域。 该属性指定了背景在哪些区域可以显示，但与背景开始绘制的位置无关，背景的绘制的位置可以出现在不显示背景的区域，这时就相当于背景图片被不显示背景的区域裁剪了一部分一样。 background-origin：padding|border|content 该属性指定了背景从哪个区域(边框、补白或内容)开始绘制,但也仅仅能控制背景开始绘制的位置，你可以用这个属性在边框上绘制背景，但边框上的背景显不显示出来那就要由background-clip来决定了 background-origin 属性规定 background-position 属性相对于什么位置来定位。 9）：background-size 指定背景中图像的尺寸参数 length 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 percentage 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。但这种方法会致使背景图片失真。 contain保持背景图像本身的宽高比例，将背景图像缩放到宽度或高度正好适应所定义背景容器的区域。 如何添加多个背景图 使用background-repeat和background-position可以单独指定背景图像中某个文件的平铺方式与放置的位置 10）background-break 指定内联元素的背景图像进行平铺时的循环方式，浏览器支持不友好，bounding-box：背景图像在整个内联元素中进行平铺。 each-box：背景图像在行内中进行平铺。 continuous：下一行的背景图像紧接着上一行中的图像继续平铺。 background-break属性受限于浏览器的支持力度，目前使用度极低，仅在Firefox下能实现，而且还需要修改属性写法，在此仅让大家参考。 11）border-raidus 设置圆角语法：border-radius: none | {1,4}[/{1,4}] ? border-radius是一种缩写方法。 如果反斜杠符号“/”存在，“/”前面的值是设置元素圆角的水平方向半径，“/”后面的值是设置元素圆角的垂直方向的半径;如果没有“/”，则元素圆角的水平和垂直方向的半径值相等。另外四个值是按照top-left、top-right、bottom-right和bottom-left顺序来设置的1234border-top-left-radius：&lt;length&gt;/&lt;length&gt;；定义元素左上角圆角。border-top-right-radius：&lt;length&gt;/&lt;length&gt;；定义元素右上角圆角。border-bottom-right–radius：&lt;length&gt;/&lt;length&gt;；定义元素右下角圆角。border-bottom-left-radius：&lt;length&gt;/&lt;length&gt;；定义元素左下角圆角。 上面四个子属性取值和border-radius是一样的，只不过水平和垂直方向仅一个值，“/”前面的值为水平方向半径，后面的值为垂直方向半径。如果第二个值省略，元素水平和垂直方向半径，其实就是以“”为半径的四分之一圆。如果任意一个值为“0”，这个角就不是圆角 12）：border-image 属性，可以使用图片来创建边框border-image-source 用在边框的图片的路径。 border-image-slice :number(没有单位)|percentage border-image-slice是用来分解引入进来的背景图片,图片边框向内偏移。例如边框图片的大小是 300px×240px，取百分比为25%，30%，15%，20%，它们实际对应的效果就是剪切了图片的60px，90px，36px，60px的四边大小 border-image-width 图片边框的宽度。 border-image-repeat图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)。 13）：颜色特性]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>CSS选择器</tag>
        <tag>CSS3属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的网页设计错误（上）]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为翻译的原文 原文地址http://blog-en.tilda.cc/articles-website-design-mistakes 常见的登陆页面设计错误要避免1.内容不会分解为逻辑块如果将信息分组为逻辑块，则用户更容易摘要信息。将填充设置为120 px-180 px，并使用彩色背景分隔文本块。图1-1，在相关信息集之间几乎没有填充，而且这种设计需要颜色块来将内容划分为逻辑集。结果，这些信息难以消化，并且不清楚哪个文本应该与每个块一起使用。图1-2，充足够大，块被颜色分开，这使得一件事立即清楚 - 这些块包含不同类型的内容。 2.网页上项目之间的空格不均匀应在逻辑块周围设置相同大小的空格。否则您的页面看起来会很混乱，用户可能不会对每个部分给予同等的考虑。图2-1，各种宽度的空间看起来不均匀，并且会产生一种印象，即公司信息与标题相关联，尽管每个块都同样重要。图2-2，标题周围的相同大小的空间和正文副本有助于将逻辑块视为携带同等重要的信息。 3.填充太小意味着用户无法将内容分解为逻辑块为避免逻辑部分混入，请将它们分开并在它们之间插入一个大空间（至少120像素）。图3-1，使用窄填充，组成站点的块彼此粘在一起。这会使页面超载并且非常混乱 - 网站访问者会认为这是一个纯文本，而不是具有不同含义的部分。图3-2，填充足够大，因此可以立即看到这两个块之间的差异 4.避免图像上文本复制的对比度低文本和背景之间应该有足够的对比。要使副本突出，请在图像上放置对比度滤镜。黑色是一种流行的颜色，但您也可以使用鲜艳的颜色混合搭配。 另一种选择是从一开始就使用对比图像，并将副本放在照片的暗部分上。此图像太亮，这使得阅读文本副本太困难应用于照片的滤镜使复印件易于阅读 5.一页上的样式太多一页上太多的排版和设计风格使它看起来不专业且难以阅读。要避免这种情况，请将自己限制为单个字体和两个饱和度选项，例如，普通和粗体。图5-1，由于使用了太多的排版风格，目前还不清楚重点在哪里。图5-2，一种字体，一种颜色和两种饱和度。页面上的排版看起来整洁明了。 6.颜色块太窄避免使用颜色强调窄页面元素。它看起来不太好看。例如，由于标题的大小，类型饱和度和填充，标题已经很好地标记。您想突出显示页面上的特定点吗？使用整个块的颜色背景，包括相关的标题和文本副本。图6-1，放置在彩色背景上的标题打破了页面的连续性，看起来像是独立的独立元素。图6-2，标题和相关文本都具有相同的背景。它表明它们属于同一个逻辑集。 7.窄列内的文本复制太多当窄列中有大量文本副本时，很难阅读，因为网站访问者必须从一行跳到下一行。另外，它看起来不太好看！最好减少列数并缩短文本副本，否则没有人会阅读它。图7-1，很长的，有争议的专栏很难读。图7-2，这些列中的文字很少，因此阅读它很容易。 8.中心文本过多 当文本很少时，页面上的居中文本很有效，否则用户很难有效地浏览它。同时，从24像素开始增加字体大小。 如果您需要包含大量文本，请使用具有可折叠文本副本的块（在Tilda中，它的块为TX12，TX16N或按钮BF703）。图8-1，长而居中的文本不易阅读。图8-2，标题下的短文本（两者都居中）在页面上看起来很好。 9.文本复制叠加在图像的基本部分上避免使用文本覆盖有意义的部分或图像的小细节。通过这种方式，您将使图像模糊不清并使文本难以辨认。尝试不同的线条位置，例如居中或对齐文字或垂直放置。图9-1，这个标题妨碍了女人的脸。有这么多微小的细节，很难阅读文本。图9-2，图像和文本副本易于阅读并形成良好的构图。 10.滥用视觉层次结构为了使信息层次在页面上清晰可见，封面上的标题应该大于标题的其余部分或者至少相同的大小，例如，如果标题很长的话。图10-1，标题上的标题不成比例地小于下一个标题，这令人困惑。为什么？它使第二个标题显得更加突出。图10-2，标题上的标题大于下一个块中的标题，因此整个页面看起来一致。 相同的原理适用于逻辑块内的可视层次结构。标题应该是页面上最大的设计元素，然后是较小的，不太突出的子标题。接下来，随后的功能标题应明显小于标题，并且重量相同。最小的字体应该用于功能描述。 这将有助于网站访问者区分最重要和最不重要的信息。图10-3，标题比标题更小，看起来是次要的，尽管在这种情况下它更重要。图10-4，标题是页面上最突出的元素，虽然标题以较小的类型书写，但它们仍然清晰可见。 11.一个逻辑集分为两个跟随文本的全屏图像或图库类似于单独的独立块。如果在图库周围添加填充，由于共享背景，文本副本和图像看起来都是逻辑整体。图11-1，一个全屏画廊看起来与上面的标题脱节，看起来像一个独立的块。图11-2，画廊与它上方的标题共享相同的背景，这使得整个构图看起来很稳固。 12.标题太大而且很长非常大的字体非常适合短句。如果标题很长，请使用较小尺寸的字体。它易于阅读，并为页面上的所有其他设计元素留出足够的空间。图12-1，标题太大占据整个封面，而设计元素争夺空间，标题难以阅读。图12-2，这个页面组合得很好，所有的设计元素都相互平衡，副本很容易阅读。 13.错误地使用边框样式的按钮当按钮透明时，边框是必需的。为颜色按钮添加边框没有意义，它只是另一个无意义的设计功能，它会使页面过载并使其难以阅读。 14.使用太多颜色在页面上使用太多颜色会令人困惑，并且不清楚哪些位更重要。一两种颜色足以让视觉突出显示真正重要的东西。图14-1，页面上有太多鲜艳的颜色; 这令人困惑。图14-2，一种颜色的口音创造了多样性，并且不会分散页面内容。 15.重载菜单人们访问网站以找到解决问题的方法。帮助他们！使用菜单可以帮助人们浏览网站并快速轻松地找到他们需要的内容。请勿使用过多信息使其超载。这足以拥有5-7个菜单项。此菜单包含太多信息，使网站导航更加困难。 简单的菜单可以轻松找到您需要的东西。]]></content>
      <categories>
        <category>网页设计</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3弹性盒和媒体查询、响应式布局]]></title>
    <url>%2FCSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[CSS3弹性盒和媒体查询、响应式布局简介 一、怪异盒模型的简介 二、弹性盒模型Flexbox布局（Flexible Box）模块(目前处于W3C工作草案)旨在提供一个更佳有效的布局方式，更好的控制项目的对齐和自由分配容器空间，即使它们的大小是未知的或动态的。因此得其名”flex”。Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。注：Flexbox布局比较适合Web应用程序的一些小组件和小规模的布局，而Grid布局（网格单元格布局）更适合用于一些大规模的布局。 因为Flexbox是一个模块，而不是一个单一的属性，他涉及很多东西。其中有些概念是需要我们去理解的，比如“flex容器”–&gt;一些属于容器上的属性(父元素)；“flex项目”–&gt;一些属于容器子元素上的属性 三、Flex容器属性(添加在父级元素上的)1）display：定义一个Flex容器，根据其取的值来决定是内联还是块。Flex容器会为其内容建立新的伸缩格式化上下文。两种方式`display : flex display : inline-flex 这样做将元素定义为弹性容器，其子元素即弹性子元素。 flex 值表示弹性容器为块级。占用一行。 inline-flex 值表示弹性容器为行内元素，可以多个元素并列在一行 。` 2）flex-direction：创建方轴，从而定义Flex项目在Flex容器中放置的方向。Flexbox是一种单方向的布局概念。认为Flex项目主要排列方式要么是水平排列，要么是垂直列排列 123.container &#123;flex-direction: row | row-reverse | column | column-reverse;&#125; 3）flex-wrap：默认情况之下，Flex项目都尽可能在一行显示。你可以根据flex-wrap的属性值来改变，让Flex项目多行显示。方向在这也扮演了一个重要角度，决定新的一行堆放方向。123.container &#123;flex-wrap: nowrap | wrap | wrap-reverse;&#125; 4）flex-flow(适用于flex容器元素)：这是flex-direction和flex-wrap两个属性的缩写。两个属性决定了伸缩容器的主轴与侧轴。默认值是row nowrap（中间用空格隔开）。语法： 1flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt; 5）justify-content：设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式1justify-content：flex-start | flex-end | center | space-between | space-around 当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制 6）align-items：定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。1align-items： flex-start | flex-end | center | baseline(项目位于容器的基线上) | stretch(默认值。); 伸缩项目可以在伸缩容器的当前行的侧轴上进行对齐，这类似于justify-content属性，但是是另一个方向。align-items可以用来设置伸缩容器中包括匿名伸缩项目的所有项目的对齐方式。 7）align-content：1align-content：flex-start |flex-end|center|space-between|space-around | stretch 当伸缩容器的侧轴还有多余空间时，align-content属性可以用来调准伸缩行在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的justify-content属性类似。请注意本属性在只有一行的伸缩容器上没有效果。 四、Flex项目属性(添加在子元素上的)1）order：：用整数值来定义排列顺序，数值小的排在前面。可以为负值。默认情况，Flex项目是按文档源的流顺序排列。然而，在Flex容器中可以通过order属性来控制Flex项目的顺序源。设置或检索弹性盒模型对象的子元素出現的順序。 order定义将会影响 &lt;’ position ‘&gt; 值为static元素的层叠级别，数值小的会被数值大的盖住。 2）flex-grow：number该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。如果所有Flex项目的flex-grow设置为1时，表示Flex容器中的Flex项目具有相等的尺寸。如果你给其中一个Flex项目设置flex-grow的值为2，那么这个Flex项目的尺寸将是其他Flex项目两倍（其他Flex项目的flex-grow值为1）。注意：flex-grow取负值将失效。 3）flex-shrink：设置或检索弹性盒的收缩比率根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。注意：flex-shrink取负值将失效。 4）flex-basis: | | auto | content设置或检索弹性盒伸缩基准值。如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间。如果设置为0，内容不在考虑周围额外空间。如果设置为auto，额外空间会基于flex-grow值做分布。如下图所示： 5）flex：none | &lt;’ flex-grow ‘&gt; &lt;’ flex-shrink &gt;’? || &lt;’ flex-basis ‘&gt;复合属性。设置或检索弹性盒模型对象的子元素如何分配空间。 flex是flex-grow，flex-shrink和flex-basis三个属性的缩写。第二个和第三个参数(flex-shrink和flex-basis)是可选值。其默认值是0 1 auto。`如果缩写「flex: 1」, 则其计算值为「1 1 0%」 如果缩写「flex: auto」, 则其计算值为「1 1 auto」 如果「flex: none」, 则其计算值为「0 0 auto」 如果「flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值 ` 6）align-self：auto | flex-start | flex-end | center | baseline | stretch定义flex子项单独在侧轴（纵轴）方向上的对齐方式。注意：float，clear和vertical-align属性在Flex项目中无效。 五、媒体查询的概念和应用1）媒体查询的引用方法在实际中媒体类型有近10中之多，实际常用的也就那么几种。不同的媒体类型引用方法也是有很多的，常见的媒体类型的引用主要有：link标签、xml方式、@import和css3新增的@import几种。 1、 link方法：link方法引入类型其实就是在标签引入样式的时候，通过link标签中的media属性来制定不同的媒体类型，这种方式引入媒体类型时常跟着引用的样式文件走。如： 12&lt;link rel="stylesheet" type="text/css" href="style.css" media="screen" /&gt;&lt;link rel="stylesheet" type="text/css" href="print.css" media="print" /&gt; 2、 @media方式@media是css3中新引进的一个特性，被称为媒体查询。在页面中也可以通过这个属性来引入媒体查询，它和@import有点类似，也是具有2中方式 A：在样式文件中引入媒体类型： 1@media screen&#123; 选择器&#123; 你的样式代码 &#125; &#125; B：使用@media 引入媒体类型的方式是在head标签中的style引入 12345&lt;head&gt;&lt;style type="text/css"&gt;@media screen&#123;选择器&#123;你的代码样式&#125;&#125;&lt;/style&gt;&lt;/head&gt; 2）常用Media query设备特性 六、Responsive web design 响应式设计布局概念1）Responsive 设计特点Responsive 网页设计不但要考虑其元素布局的秩序，还要做到“有求必应”，因此需要满足三个条件。`1、网站必须建立灵活的网格基础； 2、引用到网站的图片必须是可伸缩的； 3、不同的显示风格，需要在Media Query上设置不同的样式`注意：缺少任何一个功能，就不能称为是合格的Responsive 网页设计 2）Responsive 中的术语1、流体网格流体网格是一个简单的网格系统，这种网格设计参考了流体设计中的网格系统，将每个网格格子使用百分比单位来控制网格大小，这种网格系统最大的好处就是让网格大小随时根据屏幕尺寸做出相对应的比例缩放。 2、弹性图片弹性图片指的是不给图片设置固定尺寸，而是根据流体网格进行缩放，用于适应各种网格的尺寸。而实现方法是比较简单，一条代码就能确定 比如img{max-width：100%；}但是在IE8浏览器会出现图片失踪的bug，如果我们给每个断点提供不同的图片是比较头疼的一件事情，所以我们可以使用：`1）、使用background-image给元素添加背景图片 2）、显示/隐藏父元素，给父元素使用不同的图片，然后通过media query来控制这些图片显示或者隐藏` 3、媒体查询媒体查询可以根据设备的尺寸，查询出适配的样式，使用这个属性可以根据用户终端设备适配对应的样式，Responsive 设计最关注的的是根据用户的使用设备的当前宽度，web页面将加载一个备用的样式，实现特定的页面风格 4、屏幕分辨率指的是用户使用的设备浏览web页面时的分辨率，比如智能手机浏览器，移动电脑浏览器，平板电脑浏览器和桌面浏览器。只有知道有哪种分辨率，才能调用对应的样式。 5、主要断点：简单来说就是设备宽度的临界点，媒体特性中min-width和max-width对应的属性值就是响应式设计中的断点值，简单来说就是使用主要断点和次要断点，创建媒体查询的条件，而每个断点会对应一个样式文件。设置断点要把握以下3个要点`1）、满足主要的断点 2）、有可能的话添加一些别的断点 3）、设置高于1024px的桌面断点。` 3）Responsive 布局技巧`1.尽量少用无关紧要的div 2.不要使用内联元素(inline) 3.尽量少用js或flash 4.丢去没用的绝对定位和浮动样式 5.屏弃任何冗余结构和不使用100%设置那么有哪些设置能帮助Responsive确定更好的布局呢？1.使用HTML5 Doctype和相关指南 2.重置好你的样式（reset.css） 3.一个简单的有语义的核心布局 4.给重要的网页元素使用简单的技巧，比如导航菜单之类元素` 4）Meta 标签定义为了让智能手机根据媒体查询匹配对应的样式，特意添加了一个特殊的meta标签。主要作用就是让智能手机浏览网页时能进行优化，并且可以自定义可视区域的尺寸和缩放级别。设置Meta标签 1&lt;name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度initial-scale： 初始的缩放比例（默认设置为1.0）minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 常见的一些网页布局单位px：绝对单位，页面按精确像素展示 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。 rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。 (另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准，所以网上很多文章提到的将html的font-size设为10方便计算不是那么可取)。 rem在移动端应用可参考淘宝的页面http://m.taobao.com (html的font-size通过动态计算获取) vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。 vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持 七、CSS3多列布局 1、column-count：分栏的个数2、column-width：分栏的宽度3、column-gap：分栏的间距4、column-rule：分栏的边框5、column-span：all/1合并分栏 火狐不支持]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>弹性盒</tag>
        <tag>媒体查询</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5简介]]></title>
    <url>%2FHTML5%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[H5标签 基础 1、H5的浏览器兼容不同的浏览器显示的效果可能不一样。因为HTML5没有一个统一的标准，不同的浏览器解析时不一样的，现在还处于一个推广的阶段，但是大部分的时一样的 2、H5新的文档声明1）Html 4的文档声明2）Html 5的文档声明在 HTML 4.01 中，DOCTYPE 声明引用 文档类型定义DTD（Document Type Definition)，因为 HTML 4.01 基于 SGML（标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言；）。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。提示：请始终向 HTML 文档添加 DOCTYPE 声明，这样浏览器才能获知文档类型。 扩展：CSS盒子模型：CSS-标准盒模型 &amp; 怪异盒模型？ CSS中Box model是分为两种: W3C标准 和 IE标准盒子模型。大多数浏览器采用W3C标准模型，而IE中则采用Microsoft自己的标准。 怪异模式是“部分浏览器在支持W3C标准的同时还保留了原来的解析模式”，怪异模式主要表现在IE内核的浏览器。DOCTYPE缺失则在ie6，ie7，ie8下将会触发怪异模式（quirks 模式）。 当不对doctype进行定义时，会触发怪异模式。 在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)在怪异模式下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值） 3、H5的特点1）更简洁、但是在实际开发中要注意书写规范，利于后期维护2）标签的语义化扩展：语义化的重要性：① 当页面加载失败的时候，还能够呈现出清晰的结构② 有利于SEO优化，利于被搜索引擎收录（即便于网络爬虫的识别）③ 在项目开发及维护时，语义化的也很大程度上降低开发难度，节省成本 DIV 和新结构标签的区别和意义3）语法更宽松4）多设备跨平台5）自适应网页设计 4、H5新增加的语义化标签 header头标签 header.html header_noLogin.htmlnav 导航标签article 文章标签aside 侧边栏导航footer 页脚 footer.htmlsection 章节、页眉、栏目 1）section表示内容区块,一般入章节、页眉、页脚或者页面中的其他部分。可以与h1-h6等元素结合起来使用，标示文档的结构 2）article表示页面中的一块与上下文不相关的独立内容，譬如博客中的一篇文章或者报纸中的一篇文章 3）asideAside表示acticle元素的内容之外的，与article元素的内容相关的辅助信息。 4）header表示页面中一个内容区块或者整个页面的标题 5）footer表示整个页面或者页面中的一个内容区块的脚注。一般来说，他会包含创作者的姓名、创作日期以及创作者联系信息。 6）nav表示页面中导航链接的部分、① 传统的导航条 ② 腾讯新闻 ③侧边栏导航 ④内业导航 ：百度百科 ⑤翻页操作 7）figure表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。规定独立的流内容（图像、图表、照片、代码等等）。使用figcaption元素为figure元素添加标题。 ◆ figure 是一种元素的组合，带有可选 标题。用来表示网页上一块独立的内容。figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。◆ figcaption 表示 figure 的标题。从属于 figure ， 并且， figure 中只能放置一个 figcaption 8）video定义视频，比如电影片段或其他视频流123456789&lt;video src="路径地址" controls&gt;您的浏览器不支持video&lt;/video&gt;&lt;!--video允许有多个source元素，source元素可以连接不同的视频文件，浏览器将使用第一个可识别的格式进行播放--&gt;&lt;source src="video.ogg" type="video/ogg"/&gt;&lt;source src="video.webm" type="video/webm"/&gt;&lt;!--提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。--&gt;&lt;!--param 元素允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 &lt;object&gt; 标签提供参数。--&gt;&lt;param name="BorderStyle" value="1" /&gt; name 定义参数的名称（用在脚本中）。 HTML5里video标签支持哪些格式的视频文件？ Ogg:带有Threora视频编码和Vorbis音频编码的Ogg文件；MPEG4：带有H.264视频编码和AAC音频编码的MPEG4文件；WebM：带有VP8视频编码和Vorbis音频编码的WebM文件 9）embedembed标签用于定义嵌套的内容，包括各种媒体，格式可以是midi、wav、AIFF、AU、MP3、Flash等 10）audio12&lt;!--定义音频，比如音乐或其他音频流--&gt;&lt;audio src="someaudio.wav"&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt; 提示：可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。 11）mark高亮显示文字，一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。 12）canvas表示图形，比如图标和其他图像。这个元素本身没有行为，仅提供一块画布，但它把一个绘图API展现给客户端js，以使脚本能够把想绘制的东西绘制到这块画布上1&lt;canvas id=“myCanvas” width=“200” height=“200”&gt;&lt;/canvas&gt; 13）Datalistdatalist提供一个事先定义好的列表，通过id与input关联，当在input内输入时就会有自动完成（autocomplete）的功能，用户将会看见一个下拉列表供其选择。 14）output表示不同类型的输出，比如脚本的输出 for：定义输出域相关的一个或多个元素。form：定义输入字段所属的一个或多个表单。name：定义对象的唯一名称。（表单提交时使用） 5、H5新增加的表单元素Search/tel/url/email/number/range/color/file/Datetime/date/month/week/time/datetime-local 1）email专门用来输入email地址的文本框,如果该文本框中内容不是email地址格式的，则不允许提交。但它不检查email地址是否存在。提交时可以为空，除非加上了required属性。 具有multiple属性，它允许在该文本框中输入一串以逗号分隔的email地址。 2）urlurl：专门用来输入URL地址的文本框。如果该文本框中内容不是URL地址格式的，则不允许提交。 3）numberNumber：专门用来输入数字的文本框。在提交时会检查其中的内容是否为数字，具有min、max、step的属性。1&lt;input name=“number1” type=“number” value=“25” min=“10” max=“100” step=“5” /&gt; 4）range是用来只允话输入一段范围内数值的文本框，它具有min属性与max属性，及step属性，可以指定每次拖动的步幅。12&lt;!--min--最小值,max--最大值,step----&gt;&lt;input name=“range1” type=“range” value=“25” min=“0” max=“100” step=“5” /&gt; 5）date pickers (date, month, week, time, datetime, datetime-local) 拥有多个可供选取日期和时间的新输入类型。 date - 选取日、月、年 Internet Explorer 或 Firefox 不支持 “month” 元素。month - 选取月、年 Internet Explorer 或 Firefox 不支持 “month” 元素。week - 选取周和年Internet Explorer 或 Firefox 不支持 “month” 元素。time - 选取时间（小时和分钟）Internet Explorer 或 Firefox 不支持 “month” 元素。datetime - 选取时间、日、月、年（UTC 时间）Internet Explorer、Firefox 或者 Chrome 不支持 “datetime 元素，Safari 中部分支持。Opera 12 以及更早的版本中完全支持。datetime-local - 选取时间、日、月、年（本地时间）Internet Explorer 或 Firefox 不支持 “month” 元素。 注意，跟 input 标签设置样式一样，但是要设置标签中局部的样式不能实现。如改变日历的背景色，颜色框的按钮效果等，这些都不可以实现。6、H5新增加的表单验证1）placeholderplaceholder属性：文本框处于未输入状态时文本框中显示的输入提示。 2）autofocusautofocus属性：给文本框、选择框、或者按钮控件加上该属性，当打开页面时，该控件自动获得国标焦点，一个页面只能有一个。 3）requiredrequired属性：验证输入不能为空 4） listlist属性：结合datalist元素使用 5） autocompleteautocomplete属性：注：表单元素要必须有name属性。输入富足和所用的自动完成功能，是一个节省输入时间，同时也十分方便的功能。只有三种：on/off/&quot;&quot;。on可是显示指定候补输入的数据列表，使用datalist元素与list属性提供候补输入的数据列表，自动完成时，可以讲该datalist元素中的数据作为候补输入的数据在文本框中显示：1&lt;input type="text" name="greeting" autoconplete="on" list ="greeting"&gt; HTML5增加了大量在提交时对表单及表单元素内容有效性验证的功能。6）自动验证 min、max、step：为包含数字或日期的 input 类型规定限定（约束）max: 最大值min: 最小值step: 数字间隔 7）取消验证novalidate 属性规定在提交表单时不应该验证 form 或 input 域。 注：novalidate 属性适用于 form以及以下类型的 input标签：text, search, url, telephone, email, password, date pickers, range 以及 color.]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode如何在浏览器中打开html文件]]></title>
    <url>%2FVScode%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%93%E5%BC%80html%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vscode默认是在控制台下查看html文件，对于我们查看和调试都很不方便，那如何在浏览器中打开呢？ 1.新建一个HTML文件 2.点击左侧的扩展，打开扩展栏 3.在扩展栏的搜索栏中输入open in browser，找到open in browser这款插件，点击右下角“安装”字样即可安装。因为我已经安装了，所以再搜索不会显示安装字样 4.安装完成后可以看一下这款插件的扩展文档，里面有插件的各种信息，及插件的使用方式等我们可以看到在默认浏览器中打开是：Alt + B，在其他浏览器中显示是：Shift+Alt+B 5.回到我们刚开始建的HTML文件，在文件中鼠标右键单击，在弹出的窗口中选择使用默认浏览器打开或者其他浏览器打开，也可以使用我们上面说的快捷键（Alt + B或Shift+Alt+B）打开。 6.假如你想用其他浏览器打开，就选择Open In Other Browsers（Shift+Alt+B，顶部会出现一个命令框，其中会显示可以使用的浏览器，选择自己需要的浏览器即可，在此，我们使用chrome打开。]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>打开html文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由打开一个新的窗口]]></title>
    <url>%2Fvue%E8%B7%AF%E7%94%B1%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[简单说一下vue路由如何打开一个新的窗口 router-link标签在vue的官方文档中 看到这大家应该会想，既然router-link不支持target=&quot;_blank&quot;属性，那我们该怎么用router-link打开一个新的窗口呢？别急，继续往下看~ 文档中还有一处描述 router-link添加tag=&quot;li&quot;属性后，居然可以变成li标签渲染出来，真特么神奇哈，那可不可以写成tag=&quot;a&quot;,从而去替代a标签呢？我们尝试着写一下 1&lt;router-link tag="a" target="_blank" to="/about"&gt;新品&lt;/router-link&gt; 编程导航 上图是官网的最新说法，vue2.0以后router.go和router.push就不支持新窗口打开的属性了，现在用一种新的方式router.resolve 123456789let routeData = this.$router.resolve(&#123; path: "/about", query: &#123; name:'lei', age: 18, phoneNum:12345678901 &#125;&#125;);window.open(routeData.href, '_blank');]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>router-link</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端vue项目国际化——vue-i18n]]></title>
    <url>%2F%E5%89%8D%E7%AB%AFvue%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96%E2%80%94%E2%80%94vue-i18n%2F</url>
    <content type="text"><![CDATA[有时候我们的项目需要支持多种语言，切换语言设置时，就自动切换整个项目的文字显示。 安装 vue-i18n123456// npm 安装npm install vue-i18n// script 引入&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-i18n/dist/vue-i18n.js"&gt;&lt;/script&gt; 使用在 main.js 中引入 vue-i18n1234567891011121314151617181920import VueI18n from 'vue-i18n';Vue.use(VueI18n);const i18n = new VueI18n(&#123; locale: 'zh-CN', // 语言标识 // this.$i18n.locale // 通过切换locale的值来实现语言切换 messages: &#123; 'zh-CN': require('./languages/lang/zh'), // 中文语言包 'en-US': require('./languages/lang/en') // 英文语言包 &#125;&#125;)new Vue(&#123; el: '#app', i18n, // 把 i18n 挂载到 vue 根实例上 store, router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 上面即是将 vue-i18n 引入 vue 项目中，引入以后，实现国际化，当然至少需要两种语言，我们假设需要中英文两种语言切换，那么我们就需要中英两套语言的文件，只需要两个 js 文件，通过 require 的形式引入到 main.js。 项目下新增一个目录languages123456---src --languages --lang -- zh.js // 中文语言包 -- en.js // 英文语言包 -- .. // 其他语言，暂未实践 zh 12345678export const m = &#123; common: &#123; message: '消息' &#125;, xxx: &#123; ... &#125;&#125; en 12345678export const m = &#123; common: &#123; message: 'Messages' &#125;, xxx: &#123; ... &#125;&#125; 数据渲染1234567891011&lt;template&gt; ... // v-text &lt;div v-text="$t('m.common.message')"&gt;&lt;/div&gt; // &#123;&#123;&#125;&#125; &lt;div&gt;&#123;&#123;$t('m.common.message')&#125;&#125;&lt;/div&gt; ...&lt;/template&gt;// js$t('m.common.message') 语言切换如何实现中英文的切换呢？1234567...locale: 'zh-CN', // 语言标识 messages: &#123; 'zh-CN': require('./languages/lang/zh'), // 中文语言包 'en-US': require('./languages/lang/en') // 英文语言包 &#125;... 在main.js中，我们可以发现，当locale的值为zh-CN时，当前语言为中文，当locale的值为en-US时，当前语言为英文。 我们可以做一个切换按钮，点击来实现切换中英文。123456789101112131415// 点击事件，切换语言switchLang () &#123; this.$confirm('您确定切换语言吗?', '提示', &#123; confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; const locale = this.$i18n.locale; locale === 'zh-CN' ? this.$i18n.locale = 'en-US' : this.$i18n.locale = 'zh-CN'; &#125;).catch(() =&gt; &#123; this.$message(&#123; type: 'info', &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-i18n</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象用法简介]]></title>
    <url>%2FPromise%E5%AF%B9%E8%B1%A1%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[原自 阮一峰老师的 ECMAScript 6 入门 什么是promise对象 Promise是异步编程的一种解决方案,ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 从Promise对象可以获取异步操作的消息，Promise提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象的特点 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 Promise对象，可以将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点:首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。下面代码创造了一个Promise实例。12345678const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); // 异步操作失败 &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345promise.then(function (value) &#123; // success&#125;,function (error) &#123; // failure&#125;) then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。12345678function timeout (ms) &#123; return new Promise ((resolve,reject) =&gt; &#123; setTimeout(resolve,ms,'done'); &#125;)&#125;;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行。12345678910let promise = new Promise(function(resolve,regect)&#123; console.log('Promise'); resolve();&#125;);promise.then(function () &#123; console.log(resolve);&#125;);// Promise// Hi!// resolved 上面代码中，Promise新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行（因为javascript是单线程的），所以resolved最后输出。 下面是异步加载图片的例子。123456789101112function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。1234567891011121314151617181920212223242526const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。1234567const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios-指南]]></title>
    <url>%2FAxios-%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[分享一下axios的相关知识 一、axios基于promise用于浏览器和node.js的http客户端 二、特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 三、安装npm安装1npm install axios bower安装1bower install axios cdn引入1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 四、例子1.发送一个GET请求1234567891011121314151617181920// 通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 2.发送一个POST请求12345678910axios.post('/user',&#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 3.同时发起多个请求12345678910function getUserAccount () &#123; return axios.get ('/user/12345');&#125;;function getUserPermissions () &#123; return axios.get ('/user/12345/permissions');&#125;;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread (function (acct,perms) &#123; // 当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)); 五、axios的API（一）axios可以通过配置（config）来发送请求1.axios(config)123456789// 发送一个`POST`请求axios(&#123; method: 'POST', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// 获取远程图片axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); 2.axios(url[, config]) 12// 发起一个GET请求（GET是默认的请求方法）axios('/user/12345'); （二）请求方法别名为了方便我们为所有支持的请求方法均提供了别名。12345678axios.request(url);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.options(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]]);axios.patch(url[,data[,config]]); 注意：当使用以上别名方法时，url，method和data等属性不用在config重复声明。 （三）同时发生的请求（Concurrency）以下两个用来处理同时发生多个请求的辅助函数1234// iterable是一个可以迭代的参数,如数组等axios.all(iterable);// callback要等到所有请求都完成才会执行axios.spread(callback) （四）创建一个实例你可以创建一个拥有通用配置的axios实例1.axios.creat([config])12345var instance = axios.cerate(&#123; baseURL:'https://some-domain.com/api/', timeout:1000, headers:&#123;'X-Custom-Header':'foobar'&#125;&#125;); 2.实例的方法以下是所有可用的实例方法，额外声明的配置将与利用create创建的实例配置合并12345678axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 六、请求的配置（request config）以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123; // `url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:"Fred" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:"zhangsan", password: "s00sdkf" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 作者：FunnySeeker链接：https://www.jianshu.com/p/df464b26ae58來源：简书 六、响应组成（请求返回的内容）1.response由以下几部分信息组成1234567891011121314&#123; // 服务端返回的数据 data: &#123;&#125;, // 服务端返回的状态码 status: 200, // 服务端返回的状态信息 statusText: 'OK', // 响应头,所有的响应头名称都是小写 headers: &#123;&#125;, // axios请求配置 config: &#123;&#125;, // 请求 request: &#123;&#125;&#125; 2.用then接收以下响应信息12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 七、默认配置1.全局修改axios默认配置123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2.自定义的实例默认设置123456// 创建实例时修改配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 实例创建之后修改配置instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 3.配置优先级配置项通过一定的规则合并，request config&gt; instance.defaults&gt; 系统默认，优先级高的覆盖优先级低的。12345678// 创建一个实例，这时的超时时间为系统默认的 0var instance = axios.create();// 通过instance.defaults重新设置超时时间为2.5s，因为优先级比系统默认高instance.defaults.timeout = 2500;// 通过request config重新设置超时时间为5s，因为优先级比instance.defaults和系统默认都高instance.get('/longRequest', &#123; timeout: 5000&#125;); 八、拦截器1.你可以在then和catch之前拦截请求和响应。1234567891011121314151617// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; // Do something before request is sent return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);// 添加一个响应拦截器axios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); 2.移除拦截器12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 3.为axios实例添加一个拦截器12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 九、错误处理12345678910111213141516axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 发送请求后，服务端返回的响应码不是 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 发送请求但是没有响应返回 console.log(error.request); &#125; else &#123; // 其他错误 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 可以用validateStatus定义一个http状态码返回的范围12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // Reject only if the status code is greater than or equal to 500 &#125;&#125;) 十、取消请求 你可以通过cancel token来取消一个请求1.你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415ar CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance("操作被用户取消"); 2.你可以给cancelToken构造函数传递一个executor function来创建一个cancel token12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)//取消请求cancel();]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element-ui自定义table表头，修改列标题样式、添加tooltip,:render-header使用简介]]></title>
    <url>%2FElement-ui%E8%87%AA%E5%AE%9A%E4%B9%89table%E8%A1%A8%E5%A4%B4%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%88%97%E6%A0%87%E9%A2%98%E6%A0%B7%E5%BC%8F%E3%80%81%E6%B7%BB%E5%8A%A0tooltip-render-header%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Element-ui自定义table表头，修改列标题样式、添加tooltip,:render-header使用简介 render-headerrender-header在官方文档中的介绍是这样的： 参数 说明 类型 可选值 默认值 render-header 列标题 Label 区域渲染使用的 Function Function(h, { column, $index }) — — 修改列标题样式1.在列标题后面加一个图标。 以element-ui官方文档一个table表格为例，我们在地址的后面加一个定位标志的图标，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;el-table :data="tableData2" style="width: 100%" :row-class-name="tableRowClassName"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址" :render-header="renderHeader"&gt; // 加入render事件 &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;style&gt; .el-table .warning-row &#123; background: oldlace; &#125; .el-table .success-row &#123; background: #f0f9eb; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; methods: &#123; tableRowClassName(&#123;row, rowIndex&#125;) &#123; if (rowIndex === 1) &#123; return 'warning-row'; &#125; else if (rowIndex === 3) &#123; return 'success-row'; &#125; return ''; &#125;, // render 事件 renderHeader (h,&#123;column&#125;) &#123; // h即为cerateElement的简写，具体可看vue官方文档 return h( 'div', [ h('span', column.label), h('i', &#123; class:'el-icon-location', style:'color:#409eff;margin-left:5px;' &#125;) ], ); &#125; &#125;, data() &#123; return &#123; tableData2: [&#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄', &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄', &#125;, &#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;] &#125; &#125; &#125;&lt;/script&gt; 效果如下： 2.在列标题后面添加一个单选框 还是以上面的代码为例，只写关键代码： 123456789101112131415161718192021...// render 事件renderHeader (h,&#123;column&#125;) &#123; // h即为cerateElement的简写，具体可看vue官方文档 return h( 'div', [ h('span', column.label), h('el-checkbox',&#123; style:'margin-left:5px', on:&#123; change:this.select // 选中事件 &#125; &#125;) ], );&#125;,// 添加选中事件select (data) &#123; console.log(data);&#125;... 效果如下： 3.在表头添加一个Tooltip 我们经常会遇到一些奇怪的需求，但是即使再奇怪我们也不能认输，现在有一个需求，要在列表表题后面添加一个提示，我们开始尝试着做： 还是以上面的代码为例，刚开始我想直接用‘el-tooltip’，应该不是很难，然后就是这样： 123456789101112131415161718...renderHeader (h,&#123;column&#125;) &#123; return h( 'div', [ h('span', column.label), h('el-tooltip',[ h('i', &#123; class:'el-icon-question', style:'color:#409eff;margin-left:5px;' &#125;) ],&#123; content: '这是一个提示' &#125;) ] );&#125;... 运行后发现，基本样式出来了，但是提示没有 根据element-ui 关于tooltip的文档，我发现不管是effect, content还是placement 对tooltip都不管用，既然硬上不管用，就曲线救国，通过组件的方法，先造个轮子再走路 12345678910111213141516171819// 写一个PromptMessage的组件，并全局注册&lt;template&gt; &lt;div class="tooltip"&gt; &lt;el-tooltip effect="dark" placement="right"&gt; &lt;div slot="content"&gt; // 插槽，可提供多行的提示信息 &lt;p v-for="item in messages" :key="item"&gt; &#123;&#123;item&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;i class="el-icon-question" style="color:#409eff;margin-left:5px;font-size:15px;"&gt;&lt;/i&gt; &lt;/el-tooltip&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:['messages'] &#125;;&lt;/script&gt; 然后在render-header事件中使用组件 123456789101112131415...renderTip (h,&#123;column&#125;) &#123; return h( 'div',&#123; style:'display:flex;margin:auto;' &#125;, [ h('span', column.label), h('prompt-message', &#123; props: &#123;messages: ["这是住址信息"]&#125; &#125;) ] );&#125;... 这次我们发现，果然造的轮子还是挺不错的 JSX语法或许你会发现，这个原生的createElement 写起来并不简单，而且很费事，我们也可以采用JSX的方式，这个在Vue官方文档中有提到 查看文档，可以找到安装使用的方法 安装完成后想要再实现tooltip就简单了 12345678910111213...renderTip (h,&#123;column&#125;) &#123; return ( &lt;el-tooltip class="tooltip" effect="dark" placement="right"&gt; &lt;ul slot="content"&gt; &lt;li&gt;这是第一个提示&lt;/li&gt; &lt;li&gt;这是第二个提示&lt;li&gt; &lt;/ul&gt; &lt;i class="el-icon-question"&gt;&lt;/i&gt; &lt;/el-tooltip&gt; );&#125;... 这样看着很好理解，写起来也很方便]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>render-header</tag>
        <tag>tooltip</tag>
        <tag>vue</tag>
        <tag>Element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hosts 和 SwitchHosts]]></title>
    <url>%2FHosts%E5%92%8CSwitchHosts%2F</url>
    <content type="text"><![CDATA[整理了一下关于hosts和SwitchHosts知识，希望能帮到你 1.什么是 Hosts 和 SwitchHostsHostsHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 注意:Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 Hosts的存储位置hosts文件在不同操作系统（甚至不同Windows版本）的位置都不大一样: 1、Windows XP / 2000 / Vista / 7 / 8 / 8.1 / 10 : C:\windows\system32\drivers\etc\（XP系统无法使用bat批处理命令直接替换hosts，需手动替换后重新插拔网线或重启方使hosts生效） 2、Windows 95 / 98 / Me：%WinDir%\（其实就是C:\WINDOWS） 3、Linux及其他类Unix操作系统: /etc/ 4、Mac OS 9及更早的系统: System Folder: Preferences或System folder（文件格式可能与Windows和Linux所对应的文件不同） 5、Mac OS X: /private/etc（使用BSD风格的hosts文件） 6、OS/2及eComStation：&quot;bootdrive&quot;:\mptn\etc\ 7、Android：/system/etc/ 8、Symbian第1/2版手机：C:\system\data\ 9、Symbian第3版手机：C:\private\10000882\（能使用兼容AllFiles的文件浏览器访问。） 10、iPhone OS：/etc/(需要越狱) 11、iPad OS：/private/etc 12、webOS：/etc Hosts的具体作用 1、加快域名解析 对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。 2、方便局域网用户 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。 3、屏蔽网站（域名重定向） 有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或本地计算机的IP，这样就不用访问了。在WINDOWS系统中，约定 127.0.0.1 为本地计算机的IP地址, 0.0.0.0是错误的IP地址。 如果，我们在Hosts中，写入以下内容：127.0.0.1要屏蔽的网站A的域名0.0.0.0要屏蔽的网站B的域名这样，计算机解析域名A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。 4、顺利连接系统 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。 5、虚拟域名 很多时候，网站建设者需要把”软环境“搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP地址与一个”虚拟域名“做地址指向，就可以达到要求的效果，且无需花费。如：127.0.0.1 网站域名之后在浏览器地址栏中输入对应的网站域名即可。 SwitchHostsSwitchHosts 是一个管理、切换多个 hosts 方案的工具。它是一个免费开源软件。下载地址:http://oldj.github.io/SwitchHosts/#cn 2.SwitchHosts的功能1）语法高亮显示 2）允许选择多个方案 3) 点击行号可快速切换注释]]></content>
      <categories>
        <category>SwitchHosts</category>
      </categories>
      <tags>
        <tag>SwitchHosts</tag>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome(谷歌)控制台，console实用教程]]></title>
    <url>%2FChrome-%E8%B0%B7%E6%AD%8C-%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8Cconsole%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[大家在调试程序的时候，经常会用到控制台，在console下调试各种bug,在此整理了控制台console的一些用法，希望能够帮到你，话不多说，上干货 一、先简单的介绍一下chrome的控制台1.Windows：打开chrome浏览器，按f12就可以轻松的打开控制台（这里着重介绍下mac的，其实都一样，只是博主只有mac 😝） 2.mac:打开chrome浏览器，按fn+ f12就可以轻松的打开控制台（原谅我在此给百度打了一下广告，emmmm….我会考虑向他们收取广告费的..） 如果此时你发现你的控制台并不向我的一样在右面，没关系，继续往下看 首先，看箭头所指的地方有竖着的三个点，没错，就是他，请毫不犹豫的点击它 这时你会发现，出来这么个东西，重点观察最里面的小红框中的几个小方块，从左依次往右，当你点击第一个，会弹出一个窗口，如下 这就是将控制台作为一个窗口向我们展示，假如你关闭掉页面后，再次打开依然会是弹出框样式，此时不必惊慌，仔细发现，在这个弹出的页的右上角，还是有竖着的三个点，点击它会出现上一个图所示的情况，然后我们可以再点击第二个，会变成如下图所示 此时你会发现控制台跑到左边去了，这时候你应该有种恍然大悟的感觉，是的，第三个第四个就是控制台在下面和在右面（剩下的就不贴图了，挺费事的） 介绍完控制台，就该说一说console的用法了，终于可以好好说话了！😂 有小伙伴就问了为啥不用alert调试程序呢，设想一下，如果有一个数组，里面有超多的元素，但是你想知道这些元素都有哪些具体的值，如果此时用alert，那你真的会被自己整哭的，因为alert阻断线程运行，你不点击alert框的确定按钮下一个alert就不会出现。那如果用console呢？下面我们来做个测试： 12345678910let arr = [ &#123;name:'张三',age:13&#125;, &#123;name:'李四',age:14&#125;, &#123;name:'王五',age:15&#125;, &#123;name:'小明',age:16&#125;, &#123;name:'小华',age:17&#125;,];for (let item of arr) &#123; console.log(item);&#125;; 运行一下代码，发现要比alert好多了有木有~ 注意：刚打开控制台的时候，我们会发现控制台里有其他的东西，比如百度的彩蛋，其实就是招聘信息，这时我们并不想看到这些，怎么？你想看到吗？不，你不想…那如何清除呢？ 1.在控制台输入console.clear()或者直接输入clear(),运行（enter）一下，这时你发现控制台已经清空了 2.你也可以通过点击左上角标出的标志，也可以清空控制台 二、一般情况下我们用来输入信息的方法主要是用到如下五个 console.log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ensp;用于输出普通信息 console.info &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于输出提示性信息 console.error &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于输出错误信息 console.warn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于输出警示信息 console.debug &nbsp;&nbsp;&nbsp;&nbsp;用于输出调试信息 有小伙伴发现自己输入一个console方法后，想换行结果运行了，此时肯定一脸的懵逼😳，告诉你一个小技巧，```return(enter)```就可以换行啦，开不开心，意不意外！😝1234567891011### 三、其实console还提供了其他的方法供我们使用，我们可以在控制台输入console打印一下查看![console提供的方法](https://img-blog.csdnimg.cn/2018103017005462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpbmJvbGVp,size_16,color_FFFFFF,t_70)### 四、console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持```字符（%s）```、```整数（%d或%i）```、```浮点数（%f）```和```对象（%o）```四种例：```javascriptconsole.log(&apos;%d年%d月%d日&apos;,2011,3,26); console.log(&apos;圆周率是%f&apos;,3.1415926); 输出如下： **1234567```javascriptlet dog = &#123; name:&apos;金毛&apos;, color:&apos;黄色&apos;,&#125;;console.log(&apos;%o&apos;,dog); 输出如下： 五、console.dirxml用来显示网页的某个节点（node）所包含的html/xml代码例：1234567891011121314151617181920212223242526&lt;body&gt; &lt;table id="mytable"&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;A&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;bbb&lt;/td&gt; &lt;td&gt;aaa&lt;/td&gt; &lt;td&gt;ccc&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;111&lt;/td&gt; &lt;td&gt;333&lt;/td&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; window.onload = function ()&#123; var mytable = document.getElementById('mytable'); console.dirxml(mytable); &#125; &lt;/script&gt; 输出如下： 六、console.group输出一组信息的开头，console.groupEnd结束一组输出信息例：123console.group('aaa');console.warn('aaa.aaa');console.groupEnd(); 输出如下： 七、console.assert对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台例：12let isDebug = false;console.assert(isDebug,'为false时输出的信息'); 输出如下： 八、console.count 统计代码被执行的次数例：123456function myFunction () &#123; console.count('myFunction被执行的次数');&#125;;myFunction();myFunction();myFunction(); 输出如下： 九、console.dir 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等等例：123456789var myObject = &#123; name:'aa', age:12, sex:'man', myFunc: function () &#123; cpnsole.log('hello'); &#125;&#125;;console.dir(myObject); 输出如下： 十、console.time 计时开始,console.timeEnd 计时结束例：1234567// 用console.time来统计实例化1000000个对象所需时间console.time('Array initialie');var array = new Array(1000000);for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i] = new Object();&#125;;console.timeEnd('Array initialie'); 输出如下： 十一、再说下使用console.log的一些技巧 指定输出文字的样式 利用控制台输出图片 例： 12345678910// text console.log('%c 你看 ','color:red;font-size:5em;background-color:yellow'); // 3D Text console.log("%c3D Text"," text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em");// Rainbow Textconsole.log('%cRainbow Text ', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;');// Colorful CSSconsole.log("%cColorful CSS","background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em");// 输出动态图console.log("%c ", "background: url(http://g.hiphotos.baidu.com/zhidao/wh%3D450%2C600/sign=7408a51e88d4b31cf0699cbfb2e60b49/c9fcc3cec3fdfc03aca05de5d73f8794a5c22696.jpg) no-repeat center;padding-left:640px;padding-bottom: 242px;"); 输出如下：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6部分常用知识整理]]></title>
    <url>%2FES6%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[在这整理了一些常用的ES6的知识，希望能够帮助开发者更加了解和运用ES6 垃圾作用域1.let取代varES6提出两个新的声明变量的命令 let,const，其中let完全可以取代var（两者语义相同）注：var命令存在变量提升作用，let命令没有这个问题 2.全局变量和线程安全在let和const之间，建议优先使用const，尤其在全局环境，不应该设置变量，只应设置常量。const优于let的几个原因： const可以提醒阅读程序的人，这个变量不应该改变。 const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。 JavaScript编译器会对const进行优化，所以多使用const也有利于提高程序的运算效率。也就是说let和const的本质区别，其实是编译器内部的处理不同 字符串静态字符串一律使用单引号或反引号，不使用双引号，动态字符串使用反引号例：12const a = 'foobar';const b = `foo&#123;a&#125;bar`; 解构赋值1.使用数组成员对变量赋值，优先使用解构赋值例：123456const arr = [1,2,3,4];// badconst first = arr[0];const second = arr[1];// goodconst [first,second] = arr; 2.函数的参数如果是对象的成员，优先使用解构赋值例：12345678910111213// badfunction getFullName (user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName (obj) &#123; const &#123;firstName,lastName&#125; = obj;&#125;// bestfunction getFullName (&#123;firstName,lastName&#125;) &#123; ...&#125; 3.如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值，这样有利于以后添加返回值，以及更改返回值的顺序例：123456789// badfunction processInput (input) &#123; return [left,right,top,bottom];&#125;// goodfunction processInput (input) &#123; return &#123;left,right,top,bottom&#125;; const &#123;left,right&#125; = processInput (input);&#125; 对象1.单行定义的对象，最后一个成员不以逗号结尾，多行定义的对象，最后一个成员以逗号结尾例：123456789101112// badconst a = &#123;k1:v1,k2:v2,&#125;;const b = &#123; k1:v1, k2:v2&#125;;// goodconst a = &#123;k1:v1,k2:v2&#125;;const b = &#123; k1:v1, k2:v2,&#125;; 2.对象尽量静态化，一旦定义，就不得随意添加新的属性，如果添加新属性不可避免，要使用Object.assign()方法例：123456789// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign (a,&#123;x:3&#125;);// goodconst a = &#123;x:null&#125;;a.x = 3; 3.如果对象的属性名是动态的，可以在创造对象的时候使用属性表达式定义例：123456789101112// badconst obj = &#123; id:5, name:'xiaolei',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id:5, name:'xiaolei', [getKey('enabled')]:true,&#125;; 上面的代码中，对象obj的最后一个属性名，需要计算得到。这时最好利用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起，这样，所有属性就在一个地方定义了。 4.对象的属性和方法尽量采用简洁表达法，这样易于描述和书写例：1234567891011121314151617var ref = 'some value';// badconst atom = &#123; ref:ref, value:1, addValue:function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, // 注意此处的写法 value:1, addValue:function (value) &#123; return atom.value + value; &#125;,&#125;; 数组1.使用扩展运算符（…）拷贝数组例：123456789// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 2.使用Array.form方法将类似数组的对象转为数组例：12const foo = document.querySelectorAll('foo');const nodes = Array.from(foo); 函数1.立即执行函数可以写成箭头函数的额形式例：123(() =&gt; &#123; console.log('welcome to the Internet');&#125;)(); 2.那些需要函数表达式的场合，尽量使用箭头函数代替。因为这样更简洁，而且绑定了this.例：12345678910// bad[1,2,3].map(function (x) &#123; return x * x;&#125;);// good[1,2,3].map((x) =&gt; &#123; return x * x;&#125;);// best[1,2,3].map(x =&gt; x * x); 3.箭头函数形式取代Function.prototype.bind,不应再用self/_this/that 绑定this例：123456789// badconst self = this;const boundMethod = function (...params) &#123; return method.apply(self.params);&#125;;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this.params); 4.所有的配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数例：12345678// badfunction divide (a,b,option=false) &#123; ...&#125;;// goodfunction divide (a,b,&#123;option=false&#125;) &#123; ...&#125;; 5.使用默认值语法设置函数参数的默认值例：123456// badfunction handles (opts) &#123; opts = opts || &#123;&#125;;&#125;;// goodfunction handles (opts = &#123;&#125;) &#123;&#125;; 6.不要在函数体内使用arguement变量，使用rest运算符(…)代替，因为rest运算明显表明你想要获取参数，而且arguement是一个类似数组的对象，而rest运算符可以提供一个真正的数组例：123456789// badfunction concatenateAl () &#123; const args = Array.prototype.slice.call(arguements); return args.join('');&#125;;// goodfunction concatenateAl (...args) &#123; return args.join('');&#125;; Map结构1.注意区分==Object==和==Map==,只有模拟现实世界的实体对象时，才使用Object。2.如果只是需要key:value的数据结构，使用Map结构，因为Map有内建的遍历机制。例：12345678910let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;;for (let value of map.values()) &#123; console.log(value);&#125;;for (let item of map.entries()) &#123; console.log(item[0],item[1]);&#125;; Class用class取代需要prototype的操作，因为class的写法更简洁，易于理解例：1234567891011121314151617181920// badfunction Queue (contents = []) &#123; this._queue = [...contents];&#125;;Queue.prototype.pop = function () &#123; const value = this._queue[0]; this._queue.splice(0,1); return value;&#125;;// goodclass Queue &#123; constructor (contents = []) &#123; this._queue = [...contents]; &#125; pop () &#123; const value = this._queue[0]; this._queue.splice(0,1); return value; &#125;&#125; 模块1.首先Module的语法是Javascript的标准写法，坚持使用这种写法，使用import代替require例：123456// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123;func1,func2&#125; from 'moduleA'; 2.使用export取代module.exports例：12345678910111213141516// commonJs写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render () &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6写法import React from 'react';class Breadcrumbs extends React.Component&#123; render () &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default。export default 与普通的 export 不要同时使用 3.不要在模块使用通配符，因为这样可以确保你的模块之中，只有一个默认输出（export default）例：1234// badimport * as myObject from './importModule';// gooodimport myObject from './importModule'; 4.如果模块默认输出一个函数，函数名的首字母应该小写例：12function makeStyleGuide () &#123;&#125;;export default makeStyleGuide; 5.如果模块默认输出一个对象，对象名的首字母应该大写例：1234const StyleGuide () &#123; es6:&#123;&#125;&#125;;export default StyleGuide;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
