<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6部分常用知识整理]]></title>
    <url>%2F2018%2F11%2F26%2FES6%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[在这整理了一些常用的ES6的知识，希望能够帮助开发者更加了解和运用ES6 垃圾作用域1.let取代varES6提出两个新的声明变量的命令 let,const，其中let完全可以取代var（两者语义相同）注：var命令存在变量提升作用，let命令没有这个问题 2.全局变量和线程安全在let和const之间，建议优先使用const，尤其在全局环境，不应该设置变量，只应设置常量。const优于let的几个原因： const可以提醒阅读程序的人，这个变量不应该改变。 const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。 JavaScript编译器会对const进行优化，所以多使用const也有利于提高程序的运算效率。也就是说let和const的本质区别，其实是编译器内部的处理不同 字符串静态字符串一律使用单引号或反引号，不使用双引号，动态字符串使用反引号例：12const a = 'foobar';const b = `foo&#123;a&#125;bar`; 解构赋值1.使用数组成员对变量赋值，优先使用解构赋值例：123456const arr = [1,2,3,4];// badconst first = arr[0];const second = arr[1];// goodconst [first,second] = arr; 2.函数的参数如果是对象的成员，优先使用解构赋值例：12345678910111213// badfunction getFullName (user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName (obj) &#123; const &#123;firstName,lastName&#125; = obj;&#125;// bestfunction getFullName (&#123;firstName,lastName&#125;) &#123; ...&#125; 3.如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值，这样有利于以后添加返回值，以及更改返回值的顺序例：123456789// badfunction processInput (input) &#123; return [left,right,top,bottom];&#125;// goodfunction processInput (input) &#123; return &#123;left,right,top,bottom&#125;; const &#123;left,right&#125; = processInput (input);&#125; 对象1.单行定义的对象，最后一个成员不以逗号结尾，多行定义的对象，最后一个成员以逗号结尾例：123456789101112// badconst a = &#123;k1:v1,k2:v2,&#125;;const b = &#123; k1:v1, k2:v2&#125;;// goodconst a = &#123;k1:v1,k2:v2&#125;;const b = &#123; k1:v1, k2:v2,&#125;; 2.对象尽量静态化，一旦定义，就不得随意添加新的属性，如果添加新属性不可避免，要使用Object.assign()方法例：123456789// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign (a,&#123;x:3&#125;);// goodconst a = &#123;x:null&#125;;a.x = 3; 3.如果对象的属性名是动态的，可以在创造对象的时候使用属性表达式定义例：123456789101112// badconst obj = &#123; id:5, name:'xiaolei',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id:5, name:'xiaolei', [getKey('enabled')]:true,&#125;; 上面的代码中，对象obj的最后一个属性名，需要计算得到。这时最好利用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起，这样，所有属性就在一个地方定义了。 4.对象的属性和方法尽量采用简洁表达法，这样易于描述和书写例：1234567891011121314151617var ref = 'some value';// badconst atom = &#123; ref:ref, value:1, addValue:function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, // 注意此处的写法 value:1, addValue:function (value) &#123; return atom.value + value; &#125;,&#125;; 数组1.使用扩展运算符（…）拷贝数组例：123456789// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 2.使用Array.form方法将类似数组的对象转为数组例：12const foo = document.querySelectorAll('foo');const nodes = Array.from(foo); 函数1.立即执行函数可以写成箭头函数的额形式例：123(() =&gt; &#123; console.log('welcome to the Internet');&#125;)(); 2.那些需要函数表达式的场合，尽量使用箭头函数代替。因为这样更简洁，而且绑定了this.例：12345678910// bad[1,2,3].map(function (x) &#123; return x * x;&#125;);// good[1,2,3].map((x) =&gt; &#123; return x * x;&#125;);// best[1,2,3].map(x =&gt; x * x); 3.箭头函数形式取代Function.prototype.bind,不应再用self/_this/that 绑定this例：123456789// badconst self = this;const boundMethod = function (...params) &#123; return method.apply(self.params);&#125;;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this.params); 4.所有的配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数例：12345678// badfunction divide (a,b,option=false) &#123; ...&#125;;// goodfunction divide (a,b,&#123;option=false&#125;) &#123; ...&#125;; 5.使用默认值语法设置函数参数的默认值例：123456// badfunction handles (opts) &#123; opts = opts || &#123;&#125;;&#125;;// goodfunction handles (opts = &#123;&#125;) &#123;&#125;; 6.不要在函数体内使用arguement变量，使用rest运算符(…)代替，因为rest运算明显表明你想要获取参数，而且arguement是一个类似数组的对象，而rest运算符可以提供一个真正的数组例：123456789// badfunction concatenateAl () &#123; const args = Array.prototype.slice.call(arguements); return args.join('');&#125;;// goodfunction concatenateAl (...args) &#123; return args.join('');&#125;; Map结构1.注意区分==Object==和==Map==,只有模拟现实世界的实体对象时，才使用Object。2.如果只是需要key:value的数据结构，使用Map结构，因为Map有内建的遍历机制。例：12345678910let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;;for (let value of map.values()) &#123; console.log(value);&#125;;for (let item of map.entries()) &#123; console.log(item[0],item[1]);&#125;; Class用class取代需要prototype的操作，因为class的写法更简洁，易于理解例：1234567891011121314151617181920// badfunction Queue (contents = []) &#123; this._queue = [...contents];&#125;;Queue.prototype.pop = function () &#123; const value = this._queue[0]; this._queue.splice(0,1); return value;&#125;;// goodclass Queue &#123; constructor (contents = []) &#123; this._queue = [...contents]; &#125; pop () &#123; const value = this._queue[0]; this._queue.splice(0,1); return value; &#125;&#125; 模块1.首先Module的语法是Javascript的标准写法，坚持使用这种写法，使用import代替require例：123456// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123;func1,func2&#125; from 'moduleA'; 2.使用export取代module.exports例：12345678910111213141516// commonJs写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render () &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6写法import React from 'react';class Breadcrumbs extends React.Component&#123; render () &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default。export default 与普通的 export 不要同时使用 3.不要在模块使用通配符，因为这样可以确保你的模块之中，只有一个默认输出（export default）例：1234// badimport * as myObject from './importModule';// gooodimport myObject from './importModule'; 4.如果模块默认输出一个函数，函数名的首字母应该小写例：12function makeStyleGuide () &#123;&#125;;export default makeStyleGuide; 5.如果模块默认输出一个对象，对象名的首字母应该大写例：1234const StyleGuide () &#123; es6:&#123;&#125;&#125;;export default StyleGuide;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
